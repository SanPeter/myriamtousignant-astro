---
import { Image } from 'astro:assets';
import type { ImageMetadata } from 'astro';

interface Props {
  match: string;
  sortOrder?: 'asc' | 'desc';
  rowHeight?: number;
  margins?: number;
  thumbnailResizeOptions?: string;
  showExif?: boolean;
  previewType?: 'blur' | 'color';
  embedPreview?: boolean;
  thumbnailHoverEffect?: string;
  collectionName?: string;
  slug?: string;
}

const {
  match,
  sortOrder = 'asc',
  rowHeight = 200,
  margins = 10,
  thumbnailResizeOptions,
  showExif = false,
  previewType = 'blur',
  embedPreview = true,
  thumbnailHoverEffect = 'none',
  collectionName,
  slug,
} = Astro.props;

// Déterminer le chemin de collection et le slug à partir de l'URL si non fournis
const pathname = Astro.url.pathname;
const parts = pathname.split('/').filter(Boolean);
const actualCollectionName = collectionName || parts[0] || '';
const actualSlug = slug || parts[1] || '';

// Extraire le pattern de nom de fichier du paramètre match
const matchPattern = match.split('/').pop() || '';
const baseDir = match.split('/').slice(0, -1).join('/');

// Importer toutes les images potentielles à partir des chemins
const imageGlob = import.meta.glob<{ default: ImageMetadata }>([
  '../content/**/*.{jpeg,jpg,png,gif,webp,JPG,JPEG,PNG,GIF,WEBP}'
]);

// Fonction pour trouver les images correspondant au pattern
async function findMatchingImages(): Promise<ImageMetadata[]> {
  const images: ImageMetadata[] = [];
  const pattern = new RegExp(
    matchPattern.replace('*', '.*').replace('.', '\\.'),
    'i'
  );
  
  // Construire le chemin de base pour chercher les images
  const basePath = `../content/${actualCollectionName}/${actualSlug}/${baseDir}`;
  
  for (const [path, importFunc] of Object.entries(imageGlob)) {
    if (path.startsWith(basePath) && pattern.test(path)) {
      const imageModule = await importFunc();
      images.push(imageModule.default);
    }
  }
  
  // Trier les images selon sortOrder
  return images.sort((a, b) => {
    const pathA = (a as any).src || '';
    const pathB = (b as any).src || '';
    return sortOrder === 'asc'
      ? pathA.localeCompare(pathB)
      : pathB.localeCompare(pathA);
  });
}

// Récupérer les images
const images = await findMatchingImages();

// Calculer le style CSS de la grille
const gridGap = `${margins}px`;
const gridAutoRows = `${rowHeight}px`;
---

<div class="image-grid-container">
  {images.length === 0 ? (
    <div class="no-images-message">
      Aucune image ne correspond au pattern "{match}"
    </div>
  ) : (
    <div class="image-grid" style={`grid-gap: ${gridGap}; grid-auto-rows: ${gridAutoRows};`}>
      {images.map((image, index) => (
        <div 
          class="image-item"
          style={`margin-bottom: ${margins}px;`}
        >
          <a 
            href="#" 
            class="lightbox-trigger"
            data-index={index}
          >
            <Image
              src={image}
              alt={`Image ${index + 1}`}
              width={300}
              height={rowHeight}
              class={`img-grid-thumbnail ${thumbnailHoverEffect !== 'none' ? `hover-effect-${thumbnailHoverEffect}` : ''}`}
            />
            {showExif && (
              <div class="image-exif">
                {/* Exif info would go here if available */}
              </div>
            )}
          </a>
        </div>
      ))}
    </div>
  )}
  
  {/* Lightbox component for image preview */}
  <div id="lightbox" class="lightbox">
    <div class="lightbox-content">
      <span class="lightbox-close">&times;</span>
      <div class="lightbox-image-container">
        <img id="lightbox-image" />
      </div>
      <button class="lightbox-prev">&lt;</button>
      <button class="lightbox-next">&gt;</button>
    </div>
  </div>
</div>

<style define:vars={{ rowHeight: `${rowHeight}px` }}>
  .image-grid-container {
    width: 100%;
    overflow: hidden;
  }
  
  .image-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    grid-auto-flow: dense;
  }
  
  .image-item {
    overflow: hidden;
    position: relative;
    cursor: pointer;
  }
  
  .img-grid-thumbnail {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.3s ease;
  }
  
  .hover-effect-zoom:hover {
    transform: scale(1.05);
  }
  
  .hover-effect-brighten:hover {
    filter: brightness(1.2);
  }
  
  /* Lightbox styles */
  .lightbox {
    display: none;
    position: fixed;
    z-index: 1000;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
  }
  
  .lightbox-content {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
  .lightbox-image-container {
    max-width: 90%;
    max-height: 90%;
  }
  
  #lightbox-image {
    max-width: 100%;
    max-height: 90vh;
    object-fit: contain;
  }
  
  .lightbox-close {
    position: absolute;
    top: 15px;
    right: 20px;
    color: white;
    font-size: 30px;
    cursor: pointer;
  }
  
  .lightbox-prev, .lightbox-next {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.5);
    color: white;
    border: none;
    font-size: 24px;
    padding: 10px 15px;
    cursor: pointer;
  }
  
  .lightbox-prev {
    left: 10px;
  }
  
  .lightbox-next {
    right: 10px;
  }
  
  .no-images-message {
    padding: 20px;
    text-align: center;
    color: #666;
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const lightbox = document.getElementById('lightbox');
    const lightboxImage = document.getElementById('lightbox-image');
    const lightboxClose = document.querySelector('.lightbox-close');
    const lightboxPrev = document.querySelector('.lightbox-prev');
    const lightboxNext = document.querySelector('.lightbox-next');
    const triggers = document.querySelectorAll('.lightbox-trigger');
    
    if (!lightbox || !lightboxImage) return;
    
    let currentIndex = 0;
    const imagesCount = triggers.length;
    
    // Fonction pour ouvrir le lightbox
    function openLightbox(index: number) {
      if (!lightbox || !lightboxImage) return;
      
      currentIndex = index;
      const imgSrc = triggers[index]?.querySelector('img')?.getAttribute('src');
      
      if (imgSrc) {
        lightboxImage.setAttribute('src', imgSrc);
        lightbox.style.display = 'block';
        document.body.style.overflow = 'hidden';
      }
    }
    
    // Fonction pour fermer le lightbox
    function closeLightbox() {
      if (!lightbox) return;
      lightbox.style.display = 'none';
      document.body.style.overflow = '';
    }
    
    // Fonction pour naviguer au précédent
    function prevImage() {
      currentIndex = (currentIndex - 1 + imagesCount) % imagesCount;
      openLightbox(currentIndex);
    }
    
    // Fonction pour naviguer au suivant
    function nextImage() {
      currentIndex = (currentIndex + 1) % imagesCount;
      openLightbox(currentIndex);
    }
    
    // Ajouter les gestionnaires d'événements
    triggers.forEach((trigger, index) => {
      trigger.addEventListener('click', (e) => {
        e.preventDefault();
        openLightbox(index);
      });
    });
    
    lightboxClose?.addEventListener('click', closeLightbox);
    lightboxPrev?.addEventListener('click', prevImage);
    lightboxNext?.addEventListener('click', nextImage);
    
    // Fermer aussi quand on clique en dehors de l'image
    lightbox.addEventListener('click', (e) => {
      if (e.target === lightbox) {
        closeLightbox();
      }
    });
    
    // Prise en charge du clavier
    document.addEventListener('keydown', (e) => {
      if (lightbox?.style.display !== 'block') return;
      
      switch (e.key) {
        case 'Escape':
          closeLightbox();
          break;
        case 'ArrowLeft':
          prevImage();
          break;
        case 'ArrowRight':
          nextImage();
          break;
      }
    });
  });
</script>
